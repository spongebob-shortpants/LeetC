// 700. Search in a Binary Search Tree  100%
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if( root== null)return null;
        while(root!=null){
            if(root.val>val){
                root=root.left;
            }
            else if(root.val<val){
                root=root.right;
            }else{
                return root;
            }
        }
        return null;  
    }
}

//701. Insert into a Binary Search Tree  100%
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root==null){
            root=new TreeNode(val);
        }
        TreeNode node=root;
        TreeNode parent=null;
        while(node!=null){
            parent=node;
            if(node.val>val){
                node=node.left;
            }
            else if(node.val<val){
                node=node.right;
            }else{
                node.val=val;
                return root;
            }        
        }
        if(parent.val<val){
            parent.right = new TreeNode(val);
        }else{
            parent.left = new TreeNode(val);
        }
        return root;
    }
}

//450. Delete Node in a BST 


//98. Validate Binary Search Tree 31.98%
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null) return true;
        Stack<TreeNode> stack=new Stack<>();
        TreeNode temp=null;
        while(!stack.isEmpty()||root!=null){
            if(root!=null){
                stack.push(root);
                root=root.left;
            }else{
                TreeNode node=stack.pop();
                if(temp!=null&&node.val<=temp.val){
                   return false;
                }
                temp=node;
                root=node.right;
            }  
        }
        return true;
    }
}


//530.783  Minimum Absolute Difference in BST 59.17%
class Solution {
    public int getMinimumDifference(TreeNode root) {
        Stack<TreeNode> stack=new Stack<>();
        TreeNode temp=null;
        int record=Integer.MAX_VALUE;
        while(!stack.isEmpty()||root!=null){
            if(root!=null){
                stack.push(root);
                root=root.left;
            }else{
                TreeNode node=stack.pop();
                if(temp!=null){
                   record=Math.min(Math.abs(node.val-temp.val),record); 
                }
                temp=node;
                root=node.right;
            }
        }
       return record; 
    }
}


//108. Convert Sorted Array to Binary Search Tree 100%
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return arrayToBst(nums,0,nums.length-1);
    }
    public TreeNode arrayToBst (int[] nums,int start, int end){    
        if(start>end) return null;
        int mid=(start+end)>>1;
        TreeNode root=new TreeNode(nums[mid]);
        root.left=arrayToBst(nums,start,mid-1);
        root.right=arrayToBst(nums,mid+1,end);
        return root;
    }
}

//938. Range Sum of BST 6.17%
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        Stack<TreeNode> stack=new Stack<>();
        int sum=0;
        while(!stack.isEmpty()||root!=null){
            if(root!=null){
                stack.push(root);
                root=root.left;        
            }else{
                TreeNode node=stack.pop();
                if(node.val>=low && node.val<=high){
                    sum=sum+node.val;   
                }
                root=node.right;
            }
        }
        return sum;     
    }
}


//235. Lowest Common Ancestor of a Binary Search Tree 100%
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while(root!= null){
          if (p.val==root.val||q.val==root.val)return root;
          if (p.val<root.val&&q.val<root.val){
              root = root.left;
          }
          else if(p.val>root.val&&q.val>root.val){
              root = root.right;
          }
          else if((p.val<root.val&&q.val>root.val)||(p.val>root.val&&q.val<root.val)){
              return root;
            }
        }
        return root;
    }
}
